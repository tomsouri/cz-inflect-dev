#!/usr/bin/env python3.9


from __future__ import annotations

from datastructures.lemma import InflectedLemma

def compute_accuracy(pred: list[InflectedLemma], gold: list[InflectedLemma], eval_lemma: callable[[InflectedLemma, InflectedLemma], float]) -> float:
    """
    Computes accuracy of inflected forms of lemmata.

    Using a given evaluation method to evaluate a pair of gold and predicted inflected forms,
    it evaluates the whole lists of gold and predicted forms.

    Parameters:
    pred (list[InflectedLemma]): list of InflectedLemma, generated by a model, to be evaluated.
    gold (list[InflectedLemma]): list of InflectedLemma with the gold inflected forms.
    evaluate_lemmata (callable): a method that takes one predicted InflectedLemma and 
            one gold InflectedLemma, evaluates the prediction and returns a float from [0,1].
    
    Returns:
    float: The average of evaluation results over the lists.
    """ 
    return sum(eval_lemma(p,g) for (p,g) in zip(pred,gold))/len(pred)

def eval_lemma_per_inflected_form(pred: InflectedLemma, gold: InflectedLemma) -> float:
    """
    Acc. by all inflected forms.
    
    Evaluates pair of predicted and gold lemma by the percentage of all correctly inflected forms.
    """

    return sum(__eval_inflected_form(p,g) for (p,g) in zip(pred.inflected_forms, gold.inflected_forms))/len(pred.inflected_forms)

def __eval_inflected_form(pred: str, gold: str) -> float:
    """
    Defines correctness of a predicted inflected form due to the gold inflected form.

    Returns 1 if the predicted forms is one of the possible gold forms, otherwise returns 0.

    For now it assumes, that multiple possible inflected forms are separated by backslash ("/") in the gold data,
    and assumes that a predicted form is correct if it is one of the gold forms or if gold form is not known.
    """

    # Return 1 if the set of predicted forms is subset of gold forms.
    if gold == "?":
        return False
    return 1 if set(pred.split("/")) <= set(gold.split("/")) else 0

def eval_lemma_strictly(pred: InflectedLemma, gold: InflectedLemma) -> float:
    """
    Acc. per lemma (all forms must be correct).
    
    Evaluates pair of predicted and gold lemma by the correctness of all inflected forms at once.
    """
    return 1 if 0 not in [__eval_inflected_form(p,g) for (p,g) in zip(pred.inflected_forms, gold.inflected_forms)] else 0 

def method_descr(method:callable) -> str:
    """
    Extracts the first line of the method docstring.
    """
    return method.__doc__.strip().split("\n")[0]


#def compute_per_lemma_accuracy(pred: list[list[str]], true: list[list[str]]) -> float:
#    """upravit na list[InflectedLemma], list[InflectedLemma],    
#    a zobecnit pocitani accuracy - funkce compare_lemmata predana jako argument
#    (potreba zahrnout nejednoznacne gold inflected forms)"""
#    return sum(1 if p==t else 0 for (p,t) in zip(pred,true))/len(pred)

#def compute_per_word_forms_accuracy(pred: list[list[str]], true: list[list[str]]) -> float:
    # upravit na list[InflectedLemma], list[InflectedLemma],
    # a zobecnit pocitani accuracy - funkce compare_forms predana jako argument
#    chained_pred = list(itertools.chain.from_iterable(pred))
#    chained_true = itertools.chain.from_iterable(true)
#    return sum(1 if p==t else 0 for (p,t) in zip(chained_pred, chained_true))/len(chained_pred)

#a = [[1,2,3],[4,5,6],[7,8,9]]
#b = [[1,2,3],[1,1,1],[1,1,9]]
#print(compute_per_lemma_accuracy(a,b))
#print(compute_per_word_forms_accuracy(a,b))